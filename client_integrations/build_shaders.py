#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2025 Fuse Technical Group
#
# SPDX-License-Identifier: BSD-3-Clause

"""
Shader Build Script for Virtual GPU LUT Box

This script builds platform-specific GLSL shaders by concatenating the core
interpolation functions with platform-specific templates.

Usage:
    uv run python client_integrations/build_shaders.py              # Build all shaders
    uv run python client_integrations/build_shaders.py --clean      # Clean generated shaders
    uv run python client_integrations/build_shaders.py --watch      # Watch for changes (future feature)
"""

import argparse
from datetime import datetime
from pathlib import Path
import shutil


def get_version() -> str:
    """Get version from project or git tag."""
    # Try to read from pyproject.toml or fallback to git tag
    # For now, just use a simple version string
    return "1.0.0"


def build_header(template_name: str, version: str) -> str:
    """Generate auto-generated file header with SPDX license information."""
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
    return f"""/*
 * SPDX-FileCopyrightText: 2025 Fuse Technical Group
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by build_shaders.py on {timestamp}
// Source template: {template_name}
// Version: {version}
//
// To modify this shader, edit the source files in client_integrations/src/:
//   - hald_lut_core.glsl (shared interpolation functions)
//   - {template_name} (platform-specific wrapper)
//
// Then run: uv run python client_integrations/build_shaders.py

"""


def strip_spdx_header(content: str) -> str:
    """Remove SPDX header block from GLSL source file.

    This prevents duplicate headers when concatenating source files.
    The generated file will have its own SPDX header at the top.
    """
    # SPDX headers are in C-style block comments: /* ... */
    # Look for the pattern and remove it along with any trailing blank lines
    lines = content.split("\n")
    in_spdx_block = False
    output_lines = []
    skip_blank_lines = False

    for line in lines:
        # Check if we're starting an SPDX header block
        if line.strip().startswith("/*") and "SPDX-FileCopyrightText" in content[:500]:
            in_spdx_block = True
            continue

        # Check if we're ending the SPDX block
        if in_spdx_block and line.strip().endswith("*/"):
            in_spdx_block = False
            skip_blank_lines = True  # Skip blank lines after header
            continue

        # Skip lines inside SPDX block
        if in_spdx_block:
            continue

        # Skip blank lines immediately after SPDX block
        if skip_blank_lines:
            if line.strip() == "":
                continue
            skip_blank_lines = False

        output_lines.append(line)

    return "\n".join(output_lines)


def build_shader(core_path: Path, template_path: Path, output_path: Path, version: str) -> None:
    """Build a single shader by concatenating core + template."""
    # Read core functions
    with open(core_path, encoding="utf-8") as f:
        core_content = f.read()

    # Read template
    with open(template_path, encoding="utf-8") as f:
        template_content = f.read()

    # Strip SPDX headers from source files (generated file will have its own)
    core_content = strip_spdx_header(core_content)
    template_content = strip_spdx_header(template_content)

    # Generate header
    header = build_header(template_path.name, version)

    # Forward declarations for core functions
    forward_decls = """// Forward declarations of core functions
vec2 calculateHaldUV(vec3 lutCoord, float lutSize);
vec3 applyTetrahedralLUT(vec3 color, sampler2D haldLUT, float lutSize);

"""

    # Concatenate: header → forward decls → template → core implementations
    output_content = header + forward_decls + template_content + "\n\n" + core_content

    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Write output
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(output_content)

    print(f"Built: {output_path.name}")


def build_all_shaders(src_dir: Path, output_dir: Path, version: str) -> None:
    """Build all shader templates."""
    core_path = src_dir / "hald_lut_core.glsl"

    if not core_path.exists():
        raise FileNotFoundError(f"Core shader not found: {core_path}")

    # Find all template files
    templates = list(src_dir.glob("*.template.glsl"))

    if not templates:
        print("Warning: No template files found in client_integrations/src/")
        return

    print(f"Building {len(templates)} shader(s)...")

    for template_path in templates:
        # Output filename: strip ".template" from name
        output_name = template_path.name.replace(".template", "")
        output_path = output_dir / output_name

        build_shader(core_path, template_path, output_path, version)

    print(f"\nAll shaders built successfully to: {output_dir}")


def clean_output_dir(output_dir: Path) -> None:
    """Clean generated shader files from output directory."""
    # Remove all generated .glsl files (not .template.glsl)
    cleaned_count = 0
    for glsl_file in output_dir.glob("*.glsl"):
        if not glsl_file.name.endswith(".template.glsl"):
            glsl_file.unlink()
            print(f"Removed: {glsl_file.name}")
            cleaned_count += 1

    if cleaned_count == 0:
        print("No generated shader files to clean")
    else:
        print(f"Cleaned {cleaned_count} generated shader(s)")


def main() -> None:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Build platform-specific GLSL shaders for Virtual GPU LUT Box"
    )
    parser.add_argument(
        "--clean", action="store_true", help="Clean build directory before building"
    )
    parser.add_argument(
        "--watch",
        action="store_true",
        help="Watch for changes and rebuild (not implemented yet)",
    )

    args = parser.parse_args()

    # Paths relative to this script
    script_dir = Path(__file__).parent
    src_dir = script_dir / "src"
    output_dir = script_dir  # Output to same directory as script

    version = get_version()

    try:
        if args.watch:
            print("Error: --watch mode not yet implemented")
            return

        if args.clean:
            clean_output_dir(output_dir)

        build_all_shaders(src_dir, output_dir, version)

    except Exception as e:
        print(f"Error: {e}")
        raise


if __name__ == "__main__":
    main()
